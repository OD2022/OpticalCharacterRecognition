# -*- coding: utf-8 -*-
"""preprocessing_pipeline.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LIZ00kuP1R3nrbUIOM_MWX3YMYtCAOXF

##Importing necessary Libraries
"""

import cv2 as cv
import numpy as np
import os
import functools
import argparse
import tensorflow as tf
from matplotlib import pyplot as plt
from tensorflow import keras
import statistics
import imutils
from imutils.contours import sort_contours


from google.colab import drive  
drive.mount ('/content/drive', force_remount=True) 
photo3 =  "photo3.png"
letterg = "G.jpg"
letterc = "c.jpg"
model = keras.models.load_model('/content/drive/My Drive/AIPROJECT/aiModel/model2')

"""###Function to read in image"""

def read_image(image_path):
  image = cv.imread(image_path)
  gray_image = cv.cvtColor(image, cv.COLOR_BGR2GRAY)
  return gray_image

"""##Function to binarize an image

"""

def binarize(image):
  threshold, binarized_image = cv.threshold(image, 0, 255,cv.THRESH_OTSU | cv.THRESH_BINARY_INV)
  return binarized_image

"""##Function to denoise an image"""

def denoise(image):
  noiseless_image = cv.fastNlMeansDenoising(image, None, 20, 7, 21) 
  return noiseless_image

"""##Function to thin and skeletonize"""

def skeletonize(image):
  kernel = np.ones((1,1),np.uint8)
  erosion = cv.erode(image,kernel,iterations = 1)
  return erosion

def padImage(image):
  width = 28
  height = 28
  rows = image.shape[0]
  columns = image.shape[1]
  paddingY = (height - rows) //2
  paddingX = (width - columns) //2
  padding_rows = (height - rows) 
  padding_cols = (width - columns)
  if(image.shape[0] < 28 or image.shape[1] < 28):
    image = np.pad(image,[(paddingY, padding_rows-paddingY), (0,0)], mode="constant")
    image = np.pad(image, [(0, 0), (paddingX, padding_cols-paddingX)], mode="constant")
  else:
    return image

def cnn_prep(image):
  image = image
  image = padImage(image)
  image = cv.resize(image, (28,28), interpolation = cv.INTER_AREA)
  keras.utils.normalize(image, axis=1) 
  image = np.array(image).reshape(-1, 28, 28, 1) 
  image = image.astype('float')
  return image

"""##Function to segment into lines, then into words, then into characters."""

def check_text(list_of_images):
  char_digit_labels = {
    0 : '0',
    1 : '1',
    2 : '2',
    3 : '3',
    4 : '4',
    5 : '5',
    6 : '6',
    7 : '7',
    8 : '8',
    9 : '9',
    10 : 'A',
    11 : 'B',
    12 : 'C',
    13 : 'D',
    14 : 'E',
    15 : 'F',
    16 : 'G',
    17 : 'H',
    18 : 'I',
    19 : 'J',
    20 : 'K',
    21 : 'L',
    22 : 'M',
    23 : 'N',
    24 : 'O',
    25 : 'P',
    26 : 'Q',
    27 : 'R',
    28 : 'S',
    29 : 'T',
    30 : 'U',
    31 : 'V',
    32 : 'W',
    33 : 'X',
    34 : 'Y',
    35 : 'Z',
}
  for image in list_of_images:
    photo = binarize(skeletonize(denoise(read_image(image))))
    photo = cnn_prep(photo)
    prediction = np.argmax(model.predict(photo))
    print("This the prediction", char_digit_labels[prediction])

def process(characters_lists):
  document_words = {} #Dictionary to store images of words, Key is a number, value is a list of predictions of characters
  char_digit_labels = {
    0 : '0',
    1 : '1',
    2 : '2',
    3 : '3',
    4 : '4',
    5 : '5',
    6 : '6',
    7 : '7',
    8 : '8',
    9 : '9',
    10 : 'A',
    11 : 'B',
    12 : 'C',
    13 : 'D',
    14 : 'E',
    15 : 'F',
    16 : 'G',
    17 : 'H',
    18 : 'I',
    19 : 'J',
    20 : 'K',
    21 : 'L',
    22 : 'M',
    23 : 'N',
    24 : 'O',
    25 : 'P',
    26 : 'Q',
    27 : 'R',
    28 : 'S',
    29 : 'T',
    30 : 'U',
    31 : 'V',
    32 : 'W',
    33 : 'X',
    34 : 'Y',
    35 : 'Z',
}
  page_content = ''
  for char_list in characters_lists:
    for char in char_list:
      image = cnn_prep(char)
      prediction = np.argmax(model.predict(image))
      char_string = char_digit_labels[prediction]
      page_content +=char_string
    page_content += '  '
  return page_content

def segment(image, kh, kw):
    images_list = []
    box_image = image.copy()
    kernel = cv.getStructuringElement(cv.MORPH_RECT, (kh, kw))
    dilated = cv.dilate(image, kernel, iterations=1)
    contours, hierarchy = cv.findContours(dilated, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_NONE)
    sorted_contours = sorted(contours, key=lambda ctr : cv.boundingRect(ctr)[1])
    for cntr in sorted_contours:
      x_cor, y_cor, width, height = cv.boundingRect(cntr)
      images_list.append(box_image[y_cor:y_cor+width, x_cor:x_cor+width])
    return images_list

def findCharacters(image):
  blurred = cv.GaussianBlur(image, (3, 3), 0)
  edged = cv.Canny(blurred, 40, 160)
  contours = cv.findContours(edged.copy(), cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE)
  contours = imutils.grab_contours(contours)
  contours = sort_contours(contours, method="left-to-right")[0]
  character_images_list = []
  for contour in contours:
    x_cor, y_cor, width, height = cv.boundingRect(contour)
    region_of_interest = image[y_cor:y_cor + height, x_cor:x_cor + width]
    character_images_list.append(region_of_interest)
  return character_images_list